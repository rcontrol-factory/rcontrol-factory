<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>RCF • ROOT (Recovery Router)</title>
  <meta name="theme-color" content="#070a14" />
  <style>
    :root{color-scheme:dark;}
    body{margin:0;background:#070a14;color:#eaf0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .wrap{padding:18px;max-width:900px;margin:0 auto;}
    .card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:16px;margin:14px 0;}
    button{border:0;border-radius:999px;padding:12px 14px;font-weight:800;cursor:pointer;margin:6px 8px 0 0}
    .r{background:#ff4d4d;color:#111}
    .g{background:#35d0b5;color:#111}
    .d{background:rgba(255,255,255,.12);color:#eaf0ff;border:1px solid rgba(255,255,255,.18)}
    .muted{opacity:.85}
    pre{white-space:pre-wrap;background:rgba(0,0,0,.35);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);min-height:220px;max-height:46vh;overflow:auto;-webkit-overflow-scrolling:touch}
    code{background:rgba(255,255,255,.10);padding:2px 6px;border-radius:8px}
    a{color:#8be9ff}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);font-weight:700}
  </style>
</head>
<body>
<div class="wrap">
  <h2>RCF • ROOT (Recovery Router)</h2>

  <div class="card">
    <div class="row">
      <span class="pill" id="modePill">mode: …</span>
      <span class="pill" id="swPill">sw: …</span>
      <span class="pill" id="cachePill">caches: …</span>
    </div>

    <p class="muted" style="margin-top:10px">
      Isso roda na <b>raiz</b> do site. Por padrão, ele tenta abrir a Factory em <code>/app/</code>.
      <br/>Pra ficar aqui (recovery manual), use <code>/?recovery=1</code>.
    </p>

    <div class="row">
      <button class="r" id="u">Unregister ALL SW</button>
      <button class="r" id="c">Clear ALL Caches</button>
      <button class="d" id="k">Show SW status</button>
      <button class="d" id="s">Clear Storage (CUIDADO)</button>
      <button class="g" id="go">Abrir /app/ (cache-bust)</button>
    </div>
  </div>

  <div class="card">
    <div><b>Status / Log</b></div>
    <pre id="log">boot…</pre>
  </div>
</div>

<script>
(function(){
  const L = document.getElementById("log");
  const log = (m)=>{ try{ L.textContent += "\n" + m; }catch{} };
  const ts = ()=> new Date().toISOString();
  const bust = (p)=> p + (p.includes("?")?"&":"?") + "cb=" + Date.now();

  const qs = new URLSearchParams(location.search || "");
  const RECOVERY_LOCK = qs.get("recovery") === "1";

  const modePill = document.getElementById("modePill");
  const swPill = document.getElementById("swPill");
  const cachePill = document.getElementById("cachePill");

  function setPill(el, txt){ try{ el.textContent = txt; }catch{} }

  async function swStatus(){
    const has = ("serviceWorker" in navigator);
    const ctrl = has ? !!navigator.serviceWorker.controller : false;

    let regs = [];
    try { regs = has ? await navigator.serviceWorker.getRegistrations() : []; } catch {}

    setPill(swPill, "sw: " + (has ? (ctrl ? "controller✅" : "no-controller") : "no-sw") + " regs=" + regs.length);

    log("[" + ts() + "] SW supported=" + has);
    if (!has) return;
    log("controller=" + ctrl);
    log("registrations=" + regs.length);
    for (const r of regs) {
      try { log(" - scope=" + (r.scope || "")); } catch {}
    }
  }

  async function cacheStatus(){
    const has = ("caches" in window);
    let keys = [];
    try { keys = has ? await caches.keys() : []; } catch {}
    setPill(cachePill, "caches: " + (has ? ("keys=" + keys.length) : "no-cache-api"));
    log("[" + ts() + "] Cache API supported=" + has + " keys=" + keys.length);
  }

  async function unregAll(){
    log("[" + ts() + "] Unregister SW (ALL)…");
    if (!("serviceWorker" in navigator)) { log("no SW support"); return; }
    const regs = await navigator.serviceWorker.getRegistrations();
    let ok=0;
    for (const r of regs){ try{ if(await r.unregister()) ok++; }catch(e){} }
    log("unregistered=" + ok + " total_regs=" + regs.length);
    try { log("controller_after=" + (!!navigator.serviceWorker.controller)); } catch {}
    await swStatus();
  }

  async function clearAllCaches(){
    log("[" + ts() + "] Clear caches (ALL)…");
    if (!("caches" in window)) { log("no caches API"); return; }
    const keys = await caches.keys();
    let del=0;
    for (const k of keys){ try{ if(await caches.delete(k)) del++; }catch(e){} }
    log("deleted=" + del + " total_keys=" + keys.length);
    await cacheStatus();
  }

  function clearStorage(){
    const ok = confirm("CUIDADO: isso apaga localStorage/sessionStorage (apps/config local). Quer mesmo zerar?");
    if (!ok) { log("[" + ts() + "] clearStorage: cancelado"); return; }

    let a=0,b=0;
    try{ a=localStorage.length; localStorage.clear(); }catch(e){}
    try{ b=sessionStorage.length; sessionStorage.clear(); }catch(e){}
    log("[" + ts() + "] storage CLEARED local=" + a + " session=" + b);
  }

  function goApp(){
    // NÃO limpa storage automático (pra não destruir apps)
    location.href = bust("/app/");
  }

  // Teste leve pra decidir redirecionar sozinho:
  // tenta dar um fetch em /app/ e em um arquivo comum (app.js) pra ver se o servidor responde.
  async function autoRoute(){
    setPill(modePill, RECOVERY_LOCK ? "mode: recovery (lock)" : "mode: auto-route");

    if (RECOVERY_LOCK) {
      log("[" + ts() + "] recovery lock ativo (/?recovery=1). Não redireciona.");
      return;
    }

    log("[" + ts() + "] auto-route: testando /app/…");
    try{
      // 1) testa /app/ (HTML)
      const r1 = await fetch(bust("/app/"), { cache: "no-store" });
      log("auto-route: /app/ status=" + r1.status);

      // 2) testa app.js (se existir)
      let ok2 = false;
      try{
        const r2 = await fetch(bust("/app/app.js"), { cache: "no-store" });
        log("auto-route: /app/app.js status=" + r2.status);
        ok2 = (r2.status >= 200 && r2.status < 500);
      }catch(e2){
        log("auto-route: /app/app.js fetch err=" + (e2 && e2.message ? e2.message : String(e2)));
      }

      // Se /app/ respondeu, já manda abrir (cache-bust)
      if (r1.status >= 200 && r1.status < 500) {
        log("[" + ts() + "] auto-route: abrindo /app/…");
        setTimeout(goApp, 300);
        return;
      }

      // fallback
      if (ok2) {
        log("[" + ts() + "] auto-route fallback: abrindo /app/ (app.js ok) …");
        setTimeout(goApp, 300);
        return;
      }

      log("[" + ts() + "] auto-route: /app/ parece indisponível. Mantendo recovery.");
      setPill(modePill, "mode: recovery (auto-fail)");
    }catch(e){
      log("auto-route err: " + (e && e.message ? e.message : String(e)));
      setPill(modePill, "mode: recovery (fetch-fail)");
    }
  }

  document.getElementById("u").onclick = unregAll;
  document.getElementById("c").onclick = clearAllCaches;
  document.getElementById("k").onclick = swStatus;
  document.getElementById("s").onclick = clearStorage;
  document.getElementById("go").onclick = goApp;

  log("[" + ts() + "] href=" + location.href);
  swStatus();
  cacheStatus();
  autoRoute();
})();
</script>
</body>
</html>
