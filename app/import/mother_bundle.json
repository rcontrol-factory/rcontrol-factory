{"version":"rcf_bundle_v1","ts":1771288007597,"files":[{"path":"app/js/core/mother_selfupdate.js","content":"/* RControl Factory — /app/js/core/mother_selfupdate.js (PADRÃO) — v2.3f\n   PATCH:\n   - Mantém BRIDGE (files[] vazio não dá erro)\n   - ✅ FIX CRÍTICO: MAE update agora usa ghcfg salvo (owner/repo/branch/path/token)\n     -> antes chamava pull({}) e dava \"ghcfg incompleto (owner/repo)\"\n   - Mantém estrutura original (patch mínimo)\n*/\n(() => {\n  \"use strict\";\n\n  if (window.RCF_MAE && window.RCF_MAE.__v23f) return;\n\n  const LS_BUNDLE_KEY       = \"rcf:mother_bundle_local\";\n  const LS_BUNDLE_RAW       = \"rcf:mother_bundle_raw\";\n  const LS_BUNDLE_META      = \"rcf:mother_bundle_meta\";\n  const LS_BUNDLE_COMPAT_1  = \"rcf:mother_bundle\";\n  const LS_BUNDLE_COMPAT_2  = \"rcf:mother_bundle_json\";\n\n  const LS_APPLY_GATE_KEY   = \"rcf:mae:apply_gate\";\n  const LS_GHCFG_KEY        = \"rcf:ghcfg\";\n\n  const log = (lvl, msg, obj) => {\n    try {\n      if (obj !== undefined) window.RCF_LOGGER?.push?.(lvl, String(msg) + \" \" + JSON.stringify(obj));\n      else window.RCF_LOGGER?.push?.(lvl, String(msg));\n    } catch {}\n    try {\n      if (obj !== undefined) console.log(\"[MAE]\", lvl, msg, obj);\n      else console.log(\"[MAE]\", lvl, msg);\n    } catch {}\n  };\n\n  function safeParse(raw, fb){\n    try { return raw ? JSON.parse(raw) : fb; } catch { return fb; }\n  }\n\n  function guessType(path) {\n    const p = String(path || \"\");\n    if (p.endsWith(\".js\")) return \"application/javascript; charset=utf-8\";\n    if (p.endsWith(\".css\")) return \"text/css; charset=utf-8\";\n    if (p.endsWith(\".html\")) return \"text/html; charset=utf-8\";\n    if (p.endsWith(\".json\")) return \"application/json; charset=utf-8\";\n    if (p.endsWith(\".txt\")) return \"text/plain; charset=utf-8\";\n    return \"text/plain; charset=utf-8\";\n  }\n\n  function isPlainObject(x){\n    return !!x && typeof x === \"object\" && !Array.isArray(x);\n  }\n\n  function pick(obj, pathArr){\n    let cur = obj;\n    for (const k of (pathArr || [])) {\n      if (!cur) return null;\n      cur = cur[k];\n    }\n    return cur ?? null;\n  }\n\n  function normalizeFilesFromAnyShape(j){\n    const candidates = [\n      [\"files\"], [\"items\"],\n      [\"bundle\",\"files\"], [\"bundle\",\"items\"],\n      [\"data\",\"files\"], [\"data\",\"items\"],\n      [\"mother\",\"files\"], [\"mother\",\"items\"],\n      [\"mother_bundle\",\"files\"], [\"mother_bundle\",\"items\"],\n      [\"payload\",\"files\"], [\"payload\",\"items\"],\n    ];\n\n    for (const p of candidates){\n      const v = pick(j, p);\n      if (Array.isArray(v)) return v; // aceita array vazio\n    }\n\n    const mapCandidates = [\n      [\"files\"], [\"overrides\"], [\"vfs\"], [\"entries\"], [\"map\"],\n      [\"bundle\",\"files\"], [\"bundle\",\"overrides\"],\n      [\"data\",\"files\"], [\"data\",\"overrides\"],\n    ];\n\n    for (const p of mapCandidates){\n      const v = pick(j, p);\n      if (isPlainObject(v)) {\n        const out = [];\n        for (const [k, val] of Object.entries(v)) {\n          const path = String(k || \"\").trim();\n          if (!path) continue;\n\n          if (typeof val === \"string\") {\n            out.push({ path, content: val, contentType: guessType(path) });\n            continue;\n          }\n\n          if (isPlainObject(val)) {\n            const content =\n              (val.content != null) ? String(val.content) :\n              (val.text != null) ? String(val.text) :\n              (val.body != null) ? String(val.body) :\n              \"\";\n            const ct = String(val.contentType || val.type || guessType(path));\n            out.push({ path, content, contentType: ct });\n            continue;\n          }\n\n          out.push({ path, content: String(val ?? \"\"), contentType: guessType(path) });\n        }\n\n        return out; // pode retornar vazio\n      }\n    }\n\n    return [];\n  }\n\n  function normalizeBundleShape(bundleText){\n    const rawTxt = String(bundleText || \"\").trim();\n    if (!rawTxt) throw new Error(\"Bundle vazio\");\n\n    let j = null;\n    try { j = JSON.parse(rawTxt); }\n    catch { throw new Error(\"Bundle não é JSON válido\"); }\n\n    const rawKeys = Object.keys(j || {});\n    const filesAny = normalizeFilesFromAnyShape(j);\n\n    if (!Array.isArray(filesAny)) {\n      log(\"err\", \"bundle normalize failed: files não é array\", rawKeys);\n      return { ok:false, rawKeys, normalized:null };\n    }\n\n    const files = (filesAny || []).map((f, idx) => {\n      if (isPlainObject(f) && (f.path || f.name)) {\n        const path = String(f.path || f.name || \"\").trim();\n        const content = (f.content != null) ? String(f.content) : \"\";\n        const ct = String(f.contentType || f.type || guessType(path));\n        if (!path) return null;\n        return { path, content, contentType: ct };\n      }\n\n      if (typeof f === \"string\") {\n        return { path: `/unknown_${idx}.txt`, content: f, contentType: \"text/plain; charset=utf-8\" };\n      }\n\n      return null;\n    }).filter(Boolean);\n\n    // BRIDGE: aceita files.length === 0\n    if (!files.length) {\n      console.warn(\"Bundle bridge detectado (files vazio). Nada para aplicar.\");\n      log(\"warn\", \"bundle bridge detectado (files vazio)\", rawKeys);\n\n      const normalized = { version: \"rcf_bundle_v1\", ts: Date.now(), files: [] };\n      return { ok:true, rawKeys, normalized, bridge:true };\n    }\n\n    const normalized = { version: \"rcf_bundle_v1\", ts: Date.now(), files };\n    return { ok:true, rawKeys, normalized };\n  }\n\n  function getLocalBundleText(){\n    const txt = String(localStorage.getItem(LS_BUNDLE_KEY) || \"\").trim();\n    return txt || \"\";\n  }\n\n  // ✅ NOVO: carregar ghcfg salvo (fonte: GH_SYNC.loadConfig OU localStorage)\n  function loadGHCfg(){\n    let cfg = {};\n    try {\n      if (window.RCF_GH_SYNC?.loadConfig) cfg = window.RCF_GH_SYNC.loadConfig() || {};\n      else cfg = safeParse(localStorage.getItem(LS_GHCFG_KEY), {}) || {};\n    } catch {\n      cfg = safeParse(localStorage.getItem(LS_GHCFG_KEY), {}) || {};\n    }\n\n    // normalizar strings\n    const out = {\n      owner: String(cfg.owner || \"\").trim(),\n      repo: String(cfg.repo || \"\").trim(),\n      branch: String(cfg.branch || \"main\").trim(),\n      path: String(cfg.path || \"app/import/mother_bundle.json\").trim(),\n      token: String(cfg.token || \"\").trim(),\n    };\n\n    // autofix default (se você usa sempre o mesmo)\n    if (!out.owner) out.owner = \"rcontrol-factory\";\n    if (!out.repo)  out.repo  = \"rcontrol-factory\";\n    if (!out.branch) out.branch = \"main\";\n    if (!out.path) out.path = \"app/import/mother_bundle.json\";\n\n    // salvar de volta (para travar o cfg correto)\n    try {\n      if (window.RCF_GH_SYNC?.saveConfig) window.RCF_GH_SYNC.saveConfig(out);\n      else localStorage.setItem(LS_GHCFG_KEY, JSON.stringify(out));\n      log(\"warn\", \"ghcfg carregado/normalizado\", { owner: out.owner, repo: out.repo, branch: out.branch, path: out.path });\n    } catch {}\n\n    return out;\n  }\n\n  function pickVFS(){\n    if (window.RCF_VFS_OVERRIDES && typeof window.RCF_VFS_OVERRIDES.put === \"function\") {\n      const o = window.RCF_VFS_OVERRIDES;\n      const clearFn =\n        (typeof o.clearOverrides === \"function\") ? o.clearOverrides.bind(o) :\n        (typeof o.clear === \"function\") ? o.clear.bind(o) :\n        null;\n      return { kind: \"OVERRIDES\", put: o.put.bind(o), clear: clearFn };\n    }\n\n    if (window.RCF_VFS && typeof window.RCF_VFS.put === \"function\") {\n      const v = window.RCF_VFS;\n      const clearFn =\n        (typeof v.clearOverrides === \"function\") ? v.clearOverrides.bind(v) :\n        (typeof v.clearAll === \"function\") ? v.clearAll.bind(v) :\n        (typeof v.clear === \"function\") ? v.clear.bind(v) :\n        null;\n      return { kind: \"VFS\", put: v.put.bind(v), clear: clearFn };\n    }\n\n    return null;\n  }\n\n  async function applyBundleToOverrides(normalizedBundleText, opts){\n    const txt = String(normalizedBundleText || \"\").trim();\n    if (!txt) throw new Error(\"Bundle normalizado vazio para aplicar\");\n\n    const bundle = JSON.parse(txt);\n\n    if (!bundle || typeof bundle !== \"object\") {\n      throw new Error(\"Bundle inválido\");\n    }\n\n    if (!(\"files\" in bundle)) {\n      throw new Error(\"Bundle sem propriedade files\");\n    }\n\n    if (!Array.isArray(bundle.files)) {\n      throw new Error(\"Bundle files não é array\");\n    }\n\n    // BRIDGE\n    if (bundle.files.length === 0) {\n      console.warn(\"Bundle bridge detectado (files vazio). Nada para aplicar.\");\n      log(\"warn\", \"apply bridge: files vazio\");\n      return { applied: 0, bridge: true };\n    }\n\n    const files = bundle.files;\n\n    const vfs = pickVFS();\n    if (!vfs || !vfs.put) throw new Error(\"Overrides VFS incompleto\");\n\n    let wrote = 0;\n    let failed = 0;\n\n    for (let i = 0; i < files.length; i++){\n      const f = files[i] || {};\n      const path = String(f.path || \"\").trim();\n      const content = (f.content != null) ? String(f.content) : \"\";\n      const contentType = String(f.contentType || guessType(path));\n\n      if (!path) { failed++; continue; }\n\n      try {\n        await Promise.resolve(vfs.put(path, content, contentType));\n        wrote++;\n      } catch (e) {\n        failed++;\n        log(\"err\", `apply fail ${path} :: ${e?.message || e}`);\n      }\n    }\n\n    return { ok:true, wrote, failed, total:files.length };\n  }\n\n  async function updateFromGitHub(opts){\n    log(\"ok\", \"update start\");\n\n    if (localStorage.getItem(LS_APPLY_GATE_KEY) == null) {\n      try { localStorage.setItem(LS_APPLY_GATE_KEY, \"1\"); } catch {}\n    }\n\n    // ✅ FIX: usa o cfg salvo (não passa {})\n    const cfg = loadGHCfg();\n\n    if (!window.RCF_GH_SYNC?.pull) throw new Error(\"RCF_GH_SYNC.pull ausente\");\n\n    const rawTxt = await window.RCF_GH_SYNC.pull(cfg);\n    const norm = normalizeBundleShape(rawTxt);\n\n    if (!norm.ok || !norm.normalized) {\n      throw new Error(\"Bundle inválido\");\n    }\n\n    localStorage.setItem(LS_BUNDLE_KEY, JSON.stringify(norm.normalized));\n\n    if (norm.bridge) {\n      return { applied: 0, bridge: true };\n    }\n\n    const wantApply = !!opts?.apply;\n    if (!wantApply) {\n      return { ok:true, passive:true, saved:true, total: norm.normalized.files.length };\n    }\n\n    return await applyBundleToOverrides(JSON.stringify(norm.normalized), opts);\n  }\n\n  async function applySaved(opts){\n    const txt = getLocalBundleText();\n    if (!txt) throw new Error(\"Sem bundle salvo.\");\n    return await applyBundleToOverrides(txt, opts);\n  }\n\n  async function clear(){\n    const vfs = pickVFS();\n    if (vfs?.clear) return await Promise.resolve(vfs.clear());\n    throw new Error(\"Overrides VFS sem clear()\");\n  }\n\n  window.RCF_MAE = {\n    __v23f: true,\n    updateFromGitHub,\n    applySaved,\n    clear,\n    getLocalBundleText\n  };\n\n  log(\"ok\", \"mother_selfupdate.js ready ✅ (bridge+ghcfg cfg fix)\");\n})();","contentType":"application/javascript; charset=utf-8"}]}