/* core/commands.js
   RControl Factory - Core Commands (single-file, no imports)
   - create/select/open/set file/write/show/apply/help
   - auto-slug
   - write mode: "write" enters capture until "/end"
   - safe/auto modes supported via ctx.flags
*/

(function () {
  "use strict";

  // ---------- Helpers ----------
  function nowISO() {
    try { return new Date().toISOString(); } catch { return "" + Date.now(); }
  }

  function isStr(x) { return typeof x === "string"; }

  function trim(s) { return (s || "").toString().trim(); }

  function slugify(name) {
    const s = trim(name)
      .toLowerCase()
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // remove acentos
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .replace(/--+/g, "-");
    return s || "app";
  }

  function validSlug(slug) {
    const s = trim(slug);
    // permite: letras, n√∫meros, h√≠fen. 2..40 chars
    return /^[a-z0-9][a-z0-9-]{1,39}$/.test(s);
  }

  function splitArgsPreserveQuotes(line) {
    // split simples: suporta "texto com espa√ßo"
    const out = [];
    let cur = "";
    let q = null;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (q) {
        if (ch === q) { q = null; continue; }
        cur += ch;
        continue;
      }
      if (ch === '"' || ch === "'") { q = ch; continue; }
      if (/\s/.test(ch)) {
        if (cur) { out.push(cur); cur = ""; }
        continue;
      }
      cur += ch;
    }
    if (cur) out.push(cur);
    return out;
  }

  function asPatch(op, data) {
    return { op: op, ...data };
  }

  // ---------- Global State (write mode / pending patch) ----------
  const G = (typeof window !== "undefined") ? window : globalThis;

  if (!G.RCF_STATE) {
    G.RCF_STATE = {
      writeMode: false,
      writeTargetFile: writeDefaultFile(),
      writeBuffer: "",
      lastCmd: "",
    };
  }

  function writeDefaultFile() {
    // arquivo padr√£o pro Agent escrever (ajusta se voc√™ usa outro)
    return "app.js";
  }

  function logInfo(msg) {
    try {
      if (G.RCF_LOG && typeof G.RCF_LOG.info === "function") return G.RCF_LOG.info(msg);
    } catch {}
    // fallback
    try { console.log("[RCF]", msg); } catch {}
  }

  // ctx esperado (se existir no app):
  // ctx = {
  //   app: { activeSlug, apps: [...] },
  //   editor: { currentFile },
  //   flags: { mode: "safe"|"auto", autoApplySafe: true/false }
  //   api: { listApps, selectApp, createApp, openEditor, setFile, getFile, writeFile, applyPatchset }
  // }
  function getMode(ctx) {
    const m = ctx && ctx.flags && ctx.flags.mode;
    return (m === "auto") ? "auto" : "safe";
  }

  function getCurrentFile(ctx) {
    const f = ctx && ctx.editor && ctx.editor.currentFile;
    return trim(f) || G.RCF_STATE.writeTargetFile || writeDefaultFile();
  }

  function setCurrentFile(ctx, file) {
    const f = trim(file);
    if (!f) return false;
    G.RCF_STATE.writeTargetFile = f;
    if (ctx && ctx.editor) ctx.editor.currentFile = f;
    // se tiver API
    try {
      if (ctx && ctx.api && typeof ctx.api.setFile === "function") ctx.api.setFile(f);
    } catch {}
    return true;
  }

  function uiResult(ok, message, patchset, meta) {
    return {
      ok: !!ok,
      message: message || "",
      patchset: patchset || [],
      meta: meta || {},
      ts: nowISO()
    };
  }

  // ---------- NLP (bem simples offline) ----------
  function nlpRoute(text) {
    const t = trim(text).toLowerCase();

    // exemplos: "cria um app chamado AgroControl"
    if (/(cria|criar|create).*(app|aplicativo)/.test(t)) return "create_nl";
    if (/(abrir|open).*(editor)/.test(t)) return "open_editor";
    if (/(listar|list)/.test(t)) return "list";
    if (/^help$|^ajuda$/.test(t)) return "help";
    return null;
  }

  // ---------- Core Router ----------
  async function runCommand(input, ctx) {
    const raw = (input == null) ? "" : String(input);
    const line = trim(raw);

    if (!line) return uiResult(true, "Digite um comando. Use: help");

    G.RCF_STATE.lastCmd = line;

    // WRITE MODE: captura at√© /end
    if (G.RCF_STATE.writeMode) {
      if (line === "/end") {
        const target = G.RCF_STATE.writeTargetFile || getCurrentFile(ctx);
        const content = G.RCF_STATE.writeBuffer;

        G.RCF_STATE.writeMode = false;
        G.RCF_STATE.writeBuffer = "";

        const ps = [asPatch("FILE_WRITE", { file: target, content })];

        const mode = getMode(ctx);
        if (mode === "auto") {
          // tentar aplicar direto se existir API
          try {
            if (ctx && ctx.api && typeof ctx.api.writeFile === "function") {
              await ctx.api.writeFile(target, content);
              logInfo(`AUTO APPLY FILE_WRITE -> ${target} (${content.length} chars)`);
              return uiResult(true, `‚úÖ Escrevi no arquivo: ${target} (auto)`, [], { applied: true });
            }
          } catch (e) {
            return uiResult(false, `Erro ao aplicar auto-write: ${e && e.message ? e.message : e}`, ps, { applied: false });
          }
        }

        // safe: vira patch pendente
        return uiResult(true, `üìù WRITE MODE finalizado. Patch pendente para: ${target}`, ps, { applied: false });
      }

      // ainda capturando
      G.RCF_STATE.writeBuffer += raw + "\n";
      return uiResult(true, `...capturando (${G.RCF_STATE.writeBuffer.length} chars). Envie /end para finalizar.`);
    }

    // comandos curtos
    const args = splitArgsPreserveQuotes(line);
    const cmd = (args[0] || "").toLowerCase();

    // NLP fallback
    const nlp = nlpRoute(line);

    // ----- HELP -----
    if (cmd === "help" || cmd === "ajuda" || nlp === "help") {
      const msg =
`Comandos:
- help
- list
- create NOME [SLUG]
- select SLUG
- open editor
- set file NOME_ARQUIVO
- write   (entra em WRITE MODE; finalize com /end)
- show    (mostra arquivo atual)
- apply   (aplica patch pendente)
Dicas:
- Se voc√™ digitar s√≥ "AgroControl", eu tento entender (create).
- create sem slug -> slug autom√°tico.
- Modo: safe (pede apply) / auto (aplica a√ß√µes seguras).`;
      return uiResult(true, msg);
    }

    // ----- LIST -----
    if (cmd === "list" || cmd === "listar" || nlp === "list") {
      try {
        if (ctx && ctx.api && typeof ctx.api.listApps === "function") {
          const apps = await ctx.api.listApps();
          const names = (apps || []).map(a => `${a.slug}${a.active ? " (ativo)" : ""}`);
          return uiResult(true, `Apps: ${names.join(", ") || "(nenhum)"}`);
        }
      } catch (e) {
        return uiResult(false, `Erro no list: ${e && e.message ? e.message : e}`);
      }
      return uiResult(true, "List: API n√£o conectada. (Sem listagem no modo offline simples)");
    }

    // ----- OPEN EDITOR -----
    if ((cmd === "open" && (args[1] || "").toLowerCase() === "editor") || nlp === "open_editor") {
      try {
        if (ctx && ctx.api && typeof ctx.api.openEditor === "function") {
          await ctx.api.openEditor();
          return uiResult(true, "‚úÖ Editor aberto.");
        }
      } catch (e) {
        return uiResult(false, `Erro ao abrir editor: ${e && e.message ? e.message : e}`);
      }
      return uiResult(true, "Open editor: OK (sem API).");
    }

    // ----- SET FILE -----
    if (cmd === "set" && (args[1] || "").toLowerCase() === "file") {
      const file = args.slice(2).join(" ");
      if (!trim(file)) return uiResult(false, "Use: set file NOME_ARQUIVO");
      setCurrentFile(ctx, file);
      return uiResult(true, `‚úÖ Arquivo atual: ${trim(file)}`);
    }

    // ----- SHOW -----
    if (cmd === "show") {
      const file = getCurrentFile(ctx);
      try {
        if (ctx && ctx.api && typeof ctx.api.getFile === "function") {
          const content = await ctx.api.getFile(file);
          const head = (content || "").slice(0, 2000);
          return uiResult(true, `üìÑ ${file} (pr√©via at√© 2000 chars):\n\n${head}`);
        }
      } catch (e) {
        return uiResult(false, `Erro show: ${e && e.message ? e.message : e}`);
      }
      return uiResult(true, `Arquivo atual: ${file} (sem API para ler conte√∫do).`);
    }

    // ----- WRITE (enter capture mode) -----
    if (cmd === "write") {
      // write pode receber "write no arquivo X" (opcional)
      // exemplos: "write app.js" ou "write file app.js"
      let target = "";
      if (args.length >= 2) {
        if ((args[1] || "").toLowerCase() === "file") target = args.slice(2).join(" ");
        else target = args.slice(1).join(" ");
      }
      target = trim(target) || getCurrentFile(ctx);

      setCurrentFile(ctx, target);

      G.RCF_STATE.writeMode = true;
      G.RCF_STATE.writeTargetFile = target;
      G.RCF_STATE.writeBuffer = "";

      return uiResult(true, `üìù WRITE MODE ativo para: ${target}\nCole o texto/c√≥digo agora. Finalize com: /end`);
    }

    // ----- APPLY (se seu app guarda patch pendente em algum lugar) -----
    if (cmd === "apply") {
      try {
        if (ctx && ctx.api && typeof ctx.api.applyPatchset === "function") {
          const res = await ctx.api.applyPatchset();
          return uiResult(true, `‚úÖ Patch aplicado. ${res ? "(ok)" : ""}`);
        }
      } catch (e) {
        return uiResult(false, `Erro apply: ${e && e.message ? e.message : e}`);
      }
      return uiResult(true, "Apply: (sem API de patchset conectada).");
    }

    // ----- CREATE -----
    // create NOME [SLUG]
    if (cmd === "create" || nlp === "create_nl") {
      // se NLP: tenta extrair nome
      let name = "";
      let slug = "";

      if (cmd === "create") {
        name = args[1] || "";
        slug = args[2] || "";
        // se o nome tiver espa√ßo e veio como "create 'Agro Control'"
        if (args.length > 3 && !slug) {
          // se user fez create Agro Control
          name = args.slice(1).join(" ");
          slug = "";
        }
      } else {
        // NLP: pega √∫ltima palavra "chamado X"
        const m = raw.match(/(chamado|chamada|named)\s+(.+)$/i);
        name = m ? trim(m[2]) : raw;
      }

      name = trim(name);
      if (!name) return uiResult(false, "Use: create NOME [SLUG]");

      if (!slug) slug = slugify(name);
      slug = slugify(slug); // garante formato
      if (!validSlug(slug)) {
        slug = slugify(slug);
      }

      if (!validSlug(slug)) {
        return uiResult(false, `Nome/slug inv√°lidos. Sugest√£o de slug: ${slugify(name)}`);
      }

      try {
        if (ctx && ctx.api && typeof ctx.api.createApp === "function") {
          await ctx.api.createApp(name, slug);
          return uiResult(true, `‚úÖ App criado: ${name} (${slug})`);
        }
      } catch (e) {
        return uiResult(false, `Erro create: ${e && e.message ? e.message : e}`);
      }

      // fallback safe patch (se n√£o tiver API)
      const ps = [asPatch("APP_CREATE", { name, slug })];
      return uiResult(true, `üß© Patch pendente para criar app: ${name} (${slug})`, ps);
    }

    // ----- SELECT -----
    if (cmd === "select") {
      const slug = slugify(args[1] || "");
      if (!validSlug(slug)) return uiResult(false, "Use: select SLUG");
      try {
        if (ctx && ctx.api && typeof ctx.api.selectApp === "function") {
          await ctx.api.selectApp(slug);
          return uiResult(true, `‚úÖ App ativo: ${slug}`);
        }
      } catch (e) {
        return uiResult(false, `Erro select: ${e && e.message ? e.message : e}`);
      }
      const ps = [asPatch("APP_SELECT", { slug })];
      return uiResult(true, `üß© Patch pendente: selecionar ${slug}`, ps);
    }

    // ----- Atalho: se digitar s√≥ um nome/slug sem comando -----
    // Ex: "agrocontrol" -> tenta select; se n√£o existir, sugere create
    if (args.length === 1) {
      const token = trim(args[0]);
      if (!token) return uiResult(true, "Use: help");

      // se parece slug, tenta select
      const candidate = slugify(token);
      if (validSlug(candidate)) {
        // tenta API de apps pra ver se existe
        try {
          if (ctx && ctx.api && typeof ctx.api.listApps === "function") {
            const apps = await ctx.api.listApps();
            const exists = (apps || []).some(a => a.slug === candidate);
            if (exists) {
              if (typeof ctx.api.selectApp === "function") {
                await ctx.api.selectApp(candidate);
                return uiResult(true, `‚úÖ App ativo: ${candidate}`);
              }
              return uiResult(true, `üß© Patch pendente: selecionar ${candidate}`, [asPatch("APP_SELECT", { slug: candidate })]);
            }
          }
        } catch {}

        // se n√£o achou, oferece create
        return uiResult(true, `N√£o encontrei "${candidate}". Quer criar? Use: create "${token}" ${candidate}`);
      }
    }

    return uiResult(false, "Comando n√£o reconhecido. Use: help");
  }

  // ---------- Public API ----------
  // Compat: exp√µe um objeto global f√°cil do app.js chamar
  G.RCF_COMMANDS = {
    run: runCommand
  };

  // alias bem direto (se seu app chama assim)
  G.runCoreCommand = runCommand;

  logInfo("core/commands.js carregado ‚úÖ");
})();
