/* core/commands.js
 * RControl Factory — Command Router (Replit-like básico)
 * - Offline-first (sem LLM)
 * - Comandos: help, list, create NOME [SLUG], select SLUG
 * - Texto natural: "cria um app chamado AgroControl"
 * - Atalho: digitar só um slug existente => auto-select
 * - Auto-slug: se digitar nome sem slug => slugify automático
 *
 * Observação: este arquivo é "standalone" (1 arquivo só) para facilitar colar no celular.
 */

(function () {
  // ---------- Helpers ----------
  function nowISO() {
    try {
      return new Date().toISOString();
    } catch (_) {
      return "" + Date.now();
    }
  }

  function slugify(str) {
    return String(str || "")
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  function ok(result, extra) {
    return Object.assign({ ok: true, result: result || "" }, extra || {});
  }

  function fail(msg, extra) {
    return Object.assign({ ok: false, error: msg || "Erro." }, extra || {});
  }

  // Storage de apps (mínimo). Se o projeto já tem storage próprio, isso ainda funciona,
  // porque aqui a gente só mantém uma lista simples para select/create não quebrar.
  const STORE_KEY_APPS = "RCF_APPS_V1";
  const STORE_KEY_ACTIVE = "RCF_ACTIVE_APP_V1";

  function loadApps() {
    try {
      const raw = localStorage.getItem(STORE_KEY_APPS);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch (_) {
      return [];
    }
  }

  function saveApps(apps) {
    try {
      localStorage.setItem(STORE_KEY_APPS, JSON.stringify(apps || []));
      return true;
    } catch (_) {
      return false;
    }
  }

  function setActive(slug) {
    try {
      localStorage.setItem(STORE_KEY_ACTIVE, slug || "");
      return true;
    } catch (_) {
      return false;
    }
  }

  function getActive() {
    try {
      return localStorage.getItem(STORE_KEY_ACTIVE) || "";
    } catch (_) {
      return "";
    }
  }

  function ensureUniqueSlug(desired, apps) {
    let slug = desired;
    if (!slug) return "";
    if (!apps.includes(slug)) return slug;
    let i = 2;
    while (apps.includes(slug + "-" + i)) i++;
    return slug + "-" + i;
  }

  // ---------- Commands (API) ----------
  function help() {
    const text =
      "Comandos:\n" +
      "- help\n" +
      "- list\n" +
      "- create NOME [SLUG]\n" +
      "- select SLUG\n\n" +
      "Atalhos:\n" +
      "- Se digitar só um slug existente -> auto select\n" +
      "- Se digitar um nome (ex: AgroControl) -> sugere create\n" +
      "- Texto natural: 'cria um app chamado AgroControl'";
    return ok(text);
  }

  function list() {
    const apps = loadApps();
    const active = getActive();
    if (!apps.length) return ok("Nenhum app ainda.");
    const lines = apps.map((s) => (s === active ? `* ${s} (ativo)` : `- ${s}`));
    return ok(lines.join("\n"), { apps, active });
  }

  function create(name, slug) {
    const apps = loadApps();
    const cleanName = String(name || "").trim();
    let cleanSlug = String(slug || "").trim();

    if (!cleanName) return fail("Nome inválido.");

    if (!cleanSlug) cleanSlug = slugify(cleanName);
    if (!cleanSlug) return fail("Nome/slug inválidos.");

    // slug seguro (min/max)
    if (!/^[a-z0-9][a-z0-9-]{1,62}[a-z0-9]$/.test(cleanSlug)) {
      // permitir slug curto tipo "a" ou "ab"
      if (!/^[a-z0-9-]{1,64}$/.test(cleanSlug)) {
        return fail("Slug inválido (use letras/números e hífen).");
      }
    }

    cleanSlug = ensureUniqueSlug(cleanSlug, apps);

    apps.push(cleanSlug);
    saveApps(apps);
    setActive(cleanSlug);

    return ok(`Criado: ${cleanName} (${cleanSlug})`, {
      created: { name: cleanName, slug: cleanSlug },
      apps,
      active: cleanSlug,
    });
  }

  function select(slug) {
    const apps = loadApps();
    const s = String(slug || "").trim();
    if (!s) return fail("Slug vazio.");
    if (!apps.includes(s)) return fail("App não encontrado.");
    setActive(s);
    return ok(`App ativo: ${s}`, { active: s });
  }

  // ---------- NLP / Router ----------
  function parseNaturalCreate(text) {
    const lower = text.toLowerCase();

    // exemplos: "cria um app chamado AgroControl"
    // "criar app agrocontrol"
    // "create agrocontrol"
    let m =
      lower.match(/^(create|criar|cria)\s+(um\s+)?(app|aplicativo)\s+(chamado\s+)?(.+)$/) ||
      lower.match(/^(create|criar|cria)\s+(.+)$/);

    if (!m) return null;

    // nome fica no último grupo
    const rawName = (m[m.length - 1] || "").trim();
    if (!rawName) return null;

    return { name: rawName };
  }

  function route(input) {
    const text = String(input || "").trim();
    const lower = text.toLowerCase();

    if (!text) return fail("Digite um comando.");

    // comandos diretos
    if (lower === "help") return help();
    if (lower === "list") return list();

    // create NOME [SLUG]
    // Aceita: create Nome slug
    // Se vier só "create AgroControl" -> auto slug
    if (/^(create|criar|cria)\b/.test(lower)) {
      // tenta natural primeiro
      const nat = parseNaturalCreate(text);
      if (nat) return create(nat.name, "");

      // split
      const parts = text.split(/\s+/);
      // parts[0]=create
      if (parts.length < 2) return fail("Use: create NOME [SLUG]");

      // se tiver 3+ tokens, pode ser "create Nome slug" OU "create Nome Composto ..."
      // Estratégia: se o último token parece slug (só letras/números/-), usa como slug.
      const last = parts[parts.length - 1];
      const maybeSlug = /^[a-z0-9-]+$/i.test(last);

      if (parts.length >= 3 && maybeSlug) {
        const name = parts.slice(1, parts.length - 1).join(" ");
        const slug = slugify(last);
        return create(name, slug);
      } else {
        const name = parts.slice(1).join(" ");
        return create(name, "");
      }
    }

    // select SLUG
    if (/^select\b/.test(lower)) {
      const parts = text.split(/\s+/);
      if (parts.length < 2) return fail("Use: select SLUG");
      return select(parts[1]);
    }

    // Atalho: se digitar só um slug existente -> auto select
    const apps = loadApps();
    const guessSlug = slugify(text);

    if (apps.includes(text)) {
      return select(text);
    }
    if (apps.includes(guessSlug)) {
      return select(guessSlug);
    }

    // Se parece nome -> sugere create
    return ok(`Entendi: "${text}". Quer criar um app com esse nome?`, {
      suggestion: `create ${text}`,
    });
  }

  // ---------- Exports ----------
  // A Factory pode chamar executeCommand(input, state) ou algo parecido.
  // A gente deixa compatível:
  function executeCommand(input /*, state */) {
    try {
      const res = route(input);
      // Padroniza resposta para UI:
      // - se UI usa res.result
      // - se UI usa res.error
      return res;
    } catch (e) {
      return fail("Falha ao executar comando.", { detail: String(e && e.message ? e.message : e) });
    }
  }

  // Exporta no window e também como módulo se existir
  // (para ambientes que usam import/export)
  try {
    // eslint-disable-next-line no-undef
    if (typeof window !== "undefined") {
      window.RCF_Commands = window.RCF_Commands || {};
      window.RCF_Commands.executeCommand = executeCommand;
      window.RCF_Commands.help = help;
      window.RCF_Commands.list = list;
      window.RCF_Commands.create = create;
      window.RCF_Commands.select = select;
    }
  } catch (_) {}

  // Para quem importa como módulo
  try {
    // eslint-disable-next-line no-undef
    if (typeof exports !== "undefined") {
      // CommonJS-like
      exports.executeCommand = executeCommand;
      exports.help = help;
      exports.list = list;
      exports.create = create;
      exports.select = select;
    }
  } catch (_) {}

  // Se o projeto usar ES Modules, ele não vai ler isso aqui via export.
  // Mas a maioria do seu UI pode chamar window.RCF_Commands.executeCommand().
})();
