/* core/commands.js
   RControl Factory ‚Äî Core Commands (single-file engine)
   - Offline-first (localStorage)
   - Patch pending (approve/apply)
   - WRITE MODE (/end) for big pastes
   - Safe/Auto modes (Replit-like)
*/

(function () {
  "use strict";

  const KEY = {
    APPS: "rcf_apps_v1",
    ACTIVE: "rcf_active_app_v1",
    ACTIVE_FILE: "rcf_active_file_v1",
    PENDING: "rcf_pending_patch_v1",
    MODES: "rcf_modes_v1",
    LOGS: "rcf_logs_v1",
    WRITE_MODE: "rcf_write_mode_v1",
  };

  // --------- utils ----------
  const nowISO = () => new Date().toISOString();
  const clamp = (s, n) => (s && s.length > n ? s.slice(0, n) + "‚Ä¶" : s || "");
  const norm = (s) => (s || "").trim();
  const normLower = (s) => norm(s).toLowerCase();

  function slugify(input) {
    let s = String(input || "")
      .trim()
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    s = s.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    return s;
  }

  function loadJSON(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }

  function saveJSON(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  function pushLog(level, msg, data) {
    const logs = loadJSON(KEY.LOGS, []);
    logs.push({
      ts: nowISO(),
      level,
      msg,
      data: data ?? null,
    });
    // keep last 500
    while (logs.length > 500) logs.shift();
    saveJSON(KEY.LOGS, logs);
  }

  function getModes() {
    const m = loadJSON(KEY.MODES, { auto: false, safe: true });
    // defaults: safe ON, auto OFF
    if (typeof m.auto !== "boolean") m.auto = false;
    if (typeof m.safe !== "boolean") m.safe = true;
    return m;
  }

  function setModes(next) {
    const cur = getModes();
    const merged = { ...cur, ...next };
    saveJSON(KEY.MODES, merged);
    pushLog("info", "Modes updated", merged);
    return merged;
  }

  // --------- app store ----------
  // store shape:
  // apps = { [slug]: { name, slug, files: { "index.html": "...", ... }, createdAt, updatedAt } }
  function getApps() {
    return loadJSON(KEY.APPS, {});
  }

  function setApps(apps) {
    saveJSON(KEY.APPS, apps);
  }

  function getActiveSlug() {
    return localStorage.getItem(KEY.ACTIVE) || "";
  }

  function setActiveSlug(slug) {
    localStorage.setItem(KEY.ACTIVE, slug || "");
  }

  function getActiveFile() {
    return localStorage.getItem(KEY.ACTIVE_FILE) || "app.js";
  }

  function setActiveFile(fname) {
    localStorage.setItem(KEY.ACTIVE_FILE, fname || "app.js");
  }

  function ensureApp(slug) {
    const apps = getApps();
    if (!apps[slug]) return null;
    return apps[slug];
  }

  function defaultFilesForApp(name, slug) {
    // Minimal skeleton so editor/preview works quickly.
    return {
      "index.html": `<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>${name}</title>
  <style>
    body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px;background:#0b1220;color:#e8f0ff}
    .card{max-width:720px;margin:0 auto;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:16px;padding:18px}
    .muted{opacity:.75}
    code,pre{background:rgba(0,0,0,.35);padding:.35em .55em;border-radius:10px}
  </style>
</head>
<body>
  <div class="card">
    <h1>${name}</h1>
    <p class="muted">App criado pelo RControl Factory. Slug: <code>${slug}</code></p>
    <p>Pr√≥ximo passo: editar arquivos e gerar ZIP.</p>
  </div>
</body>
</html>`,
      "app.js": `// ${name} - app.js
console.log("Hello from ${slug}");`,
      "manifest.json": `{
  "name": "${name}",
  "short_name": "${name}",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#0b1220",
  "theme_color": "#0b1220",
  "icons": []
}`,
      "sw.js": `self.addEventListener("install", (e)=>{ self.skipWaiting(); });
self.addEventListener("activate", (e)=>{ e.waitUntil(self.clients.claim()); });
self.addEventListener("fetch", (e)=>{ /* offline-first could be expanded */ });`,
      "styles.css": `/* ${name} styles */`
    };
  }

  // --------- patches ----------
  // pending patch shape:
  // { id, ts, type, slug, file, content, prevContent, note }
  function getPending() {
    return loadJSON(KEY.PENDING, null);
  }
  function setPending(p) {
    if (!p) localStorage.removeItem(KEY.PENDING);
    else saveJSON(KEY.PENDING, p);
  }

  function makePatch(type, payload) {
    return {
      id: "p_" + Math.random().toString(16).slice(2) + "_" + Date.now(),
      ts: nowISO(),
      type,
      ...payload
    };
  }

  function applyPatch(patch) {
    const apps = getApps();
    const app = apps[patch.slug];
    if (!app) throw new Error("App n√£o existe: " + patch.slug);

    if (patch.type === "FILE_WRITE") {
      const file = patch.file;
      if (!file) throw new Error("Arquivo n√£o definido.");
      const prev = (app.files && app.files[file]) ?? "";
      patch.prevContent = prev; // keep rollback data
      app.files = app.files || {};
      app.files[file] = patch.content ?? "";
      app.updatedAt = nowISO();
      apps[patch.slug] = app;
      setApps(apps);
      pushLog("info", "Patch applied FILE_WRITE", { slug: patch.slug, file });
      return { ok: true, patch };
    }

    throw new Error("Tipo de patch n√£o suportado: " + patch.type);
  }

  function rollbackPatch(patch) {
    if (!patch || patch.type !== "FILE_WRITE") return { ok: false, reason: "Nada para rollback." };
    const apps = getApps();
    const app = apps[patch.slug];
    if (!app) return { ok: false, reason: "App n√£o existe." };
    const file = patch.file;
    if (!file) return { ok: false, reason: "Arquivo n√£o definido." };
    app.files = app.files || {};
    app.files[file] = patch.prevContent ?? "";
    app.updatedAt = nowISO();
    apps[patch.slug] = app;
    setApps(apps);
    pushLog("warn", "Rollback FILE_WRITE", { slug: patch.slug, file });
    return { ok: true };
  }

  // --------- write mode (capture) ----------
  // state shape:
  // { on: true, startedAt, targetSlug, targetFile, buffer: [] }
  function getWriteMode() {
    return loadJSON(KEY.WRITE_MODE, { on: false });
  }
  function setWriteMode(st) {
    saveJSON(KEY.WRITE_MODE, st);
  }

  function enterWriteMode(targetSlug, targetFile) {
    const st = {
      on: true,
      startedAt: nowISO(),
      targetSlug,
      targetFile,
      buffer: []
    };
    setWriteMode(st);
    pushLog("info", "WRITE MODE ON", { targetSlug, targetFile });
    return st;
  }

  function appendWrite(text) {
    const st = getWriteMode();
    if (!st.on) return st;
    st.buffer = st.buffer || [];
    st.buffer.push(text);
    setWriteMode(st);
    return st;
  }

  function exitWriteModeAndMakePatch() {
    const st = getWriteMode();
    if (!st.on) return { ok: false, reason: "WRITE MODE n√£o est√° ativo." };

    const content = (st.buffer || []).join("\n");
    const slug = st.targetSlug || getActiveSlug();
    const file = st.targetFile || getActiveFile();

    // close write mode first to avoid corruption
    setWriteMode({ on: false });

    const patch = makePatch("FILE_WRITE", {
      slug,
      file,
      content,
      note: "WRITE MODE /end"
    });

    return { ok: true, patch };
  }

  // --------- command parsing ----------
  function parseWriteInline(input) {
    // supports: write <<< ... >>>
    const m = input.match(/write\s*<<<([\s\S]*?)>>>/i);
    if (!m) return null;
    return m[1];
  }

  function parseCreateArgs(rest) {
    // create NOME SLUG? or create "Nome do app" slug
    let s = rest.trim();
    if (!s) return null;

    // quoted name
    let name = "";
    let slug = "";
    const qm = s.match(/^"([^"]+)"\s*(.*)$/);
    if (qm) {
      name = qm[1].trim();
      slug = qm[2].trim();
    } else {
      const parts = s.split(/\s+/);
      if (parts.length === 1) {
        name = parts[0];
        slug = "";
      } else {
        // if last token looks slug-ish, treat as slug
        name = parts.slice(0, -1).join(" ");
        slug = parts[parts.length - 1];
      }
    }

    const autoSlug = slugify(slug || name);
    if (!name || !autoSlug) return null;

    return { name, slug: autoSlug };
  }

  function normalizeUserCommand(input, apps) {
    const raw = norm(input);
    if (!raw) return { cmd: "", args: "" };

    // Shortcut: if user typed a slug directly, auto select it
    const only = raw.trim();
    const onlySlug = slugify(only);
    if (onlySlug && apps[onlySlug] && !/\s/.test(only)) {
      return { cmd: "select", args: onlySlug, _hint: "shortcut_slug_select" };
    }

    // Natural language: "cria um app chamado X"
    const nl = raw.toLowerCase();
    const m1 = nl.match(/cria(r)?\s+(um\s+)?app\s+(chamado|nomeado)\s+(.+)$/i);
    if (m1) {
      const name = norm(raw.replace(/.*(chamado|nomeado)\s+/i, ""));
      const slug = slugify(name);
      return { cmd: "create", args: `"${name}" ${slug}` };
    }

    // Natural language: "criar app X"
    const m2 = nl.match(/cria(r)?\s+app\s+(.+)$/i);
    if (m2) {
      const name = norm(raw.replace(/.*app\s+/i, ""));
      const slug = slugify(name);
      return { cmd: "create", args: `"${name}" ${slug}` };
    }

    // Default split
    const first = raw.split(/\s+/)[0];
    const args = raw.slice(first.length).trim();
    return { cmd: first.toLowerCase(), args };
  }

  // --------- main runner ----------
  function run(input) {
    const apps = getApps();
    const modes = getModes();
    const activeSlug = getActiveSlug();
    const activeFile = getActiveFile();
    const pending = getPending();
    const writeMode = getWriteMode();

    const out = {
      ok: true,
      title: "",
      lines: [],
      pending: pending,
      modes,
      active: { slug: activeSlug || "-", file: activeFile || "-" },
      writeMode: writeMode.on ? { on: true, file: writeMode.targetFile, slug: writeMode.targetSlug } : { on: false }
    };

    const raw = norm(input);

    // 1) WRITE MODE capture
    if (writeMode.on) {
      if (normLower(raw) === "/end") {
        const res = exitWriteModeAndMakePatch();
        if (!res.ok) {
          out.ok = false;
          out.lines.push("WRITE MODE: erro ao finalizar: " + res.reason);
          return out;
        }

        // Safe vs Auto behavior
        if (modes.auto && !modes.safe) {
          try {
            applyPatch(res.patch);
            setPending(null);
            out.title = "WRITE MODE ‚Äî aplicado";
            out.lines.push("‚úÖ Conte√∫do aplicado direto em: " + res.patch.file);
          } catch (e) {
            setPending(res.patch);
            out.title = "WRITE MODE ‚Äî pendente (erro ao aplicar)";
            out.lines.push("‚ö†Ô∏è Patch ficou pendente. Motivo: " + (e?.message || e));
          }
        } else {
          setPending(res.patch);
          out.title = "WRITE MODE ‚Äî patch pendente";
          out.lines.push("üìå Patch pendente criado (FILE_WRITE).");
          out.lines.push("Arquivo: " + res.patch.file);
          out.lines.push("Use: apply  (ou bot√£o Aprovar sugest√£o)");
        }
        return out;
      }

      // append chunk
      appendWrite(raw);
      out.title = "WRITE MODE ‚Äî capturando";
      out.lines.push("üß≤ Capturando... (" + clamp(raw, 80) + ")");
      out.lines.push("Quando terminar, envie: /end");
      return out;
    }

    // 2) parse command (incl. natural language + shortcut)
    const parsed = normalizeUserCommand(raw, apps);
    const cmd = parsed.cmd;
    const args = parsed.args;

    // empty
    if (!cmd) {
      out.title = "Sem comando";
      out.lines.push("Digite: help");
      return out;
    }

    // helpers
    const needActiveApp = () => {
      const s = getActiveSlug();
      if (!s) throw new Error("Sem app ativo. Use: create NOME SLUG  ou  select SLUG");
      return s;
    };

    const resolveApp = (slug) => {
      const app = ensureApp(slug);
      if (!app) throw new Error("App n√£o encontrado: " + slug);
      return app;
    };

    const setStatus = (t) => (out.title = t);

    try {
      // ----- help -----
      if (cmd === "help" || cmd === "?") {
        setStatus("AGENT HELP");
        out.lines.push("Comandos:");
        out.lines.push("- help");
        out.lines.push("- list");
        out.lines.push("- create NOME SLUG  (ex: create AgroControl agrocontrol)");
        out.lines.push("- select SLUG");
        out.lines.push("- open editor | open dashboard");
        out.lines.push("- set file NOMEARQ (ex: set file app.js)");
        out.lines.push("- write  (entra em WRITE MODE; finalize com /end)");
        out.lines.push("- write <<< ... >>>  (modo inline)");
        out.lines.push("- show (mostra arquivo atual)");
        out.lines.push("- apply (aplica patch pendente)");
        out.lines.push("- discard (descarta patch pendente)");
        out.lines.push("- rollback (desfaz √∫ltimo patch aplicado se tiver prevContent)");
        out.lines.push("- mode auto on|off");
        out.lines.push("- mode safe on|off  (safe ON = sempre patch pendente)");
        out.lines.push("");
        out.lines.push("Atalho: digite s√≥ o slug existente (ex: agrocontrol) ‚Üí auto select");
        return out;
      }

      // ----- list -----
      if (cmd === "list") {
        setStatus("APPS");
        const keys = Object.keys(apps);
        if (!keys.length) {
          out.lines.push("Nenhum app ainda. Use: create Nome slug");
          return out;
        }
        out.lines.push("Apps:");
        keys.sort().forEach((k) => {
          const a = apps[k];
          const mark = k === getActiveSlug() ? "‚úÖ" : " ";
          out.lines.push(`${mark} ${a.slug} ‚Äî ${a.name}`);
        });
        return out;
      }

      // ----- create -----
      if (cmd === "create") {
        const parsedArgs = parseCreateArgs(args);
        if (!parsedArgs) throw new Error("Nome/slug inv√°lidos. Ex: create AgroControl agrocontrol");

        const { name, slug } = parsedArgs;

        if (!slug || slug.length < 2) throw new Error("Slug inv√°lido.");
        if (apps[slug]) throw new Error("J√° existe app com esse slug: " + slug);

        const app = {
          name,
          slug,
          files: defaultFilesForApp(name, slug),
          createdAt: nowISO(),
          updatedAt: nowISO()
        };

        apps[slug] = app;
        setApps(apps);
        setActiveSlug(slug);
        setActiveFile("app.js");

        pushLog("info", "App created", { slug, name });

        setStatus("CREATE OK");
        out.lines.push("‚úÖ Criado: " + name);
        out.lines.push("Slug: " + slug);
        out.lines.push("Ativo: " + slug);
        out.lines.push("Arquivo ativo: app.js");
        return out;
      }

      // ----- select -----
      if (cmd === "select") {
        const slug = slugify(args);
        if (!slug) throw new Error("Use: select SLUG");
        resolveApp(slug);
        setActiveSlug(slug);
        pushLog("info", "App selected", { slug });
        setStatus("SELECT OK");
        out.lines.push("‚úÖ App ativo: " + slug);
        return out;
      }

      // ----- open -----
      if (cmd === "open") {
        const where = normLower(args);
        setStatus("OPEN");
        if (where.includes("editor")) out.lines.push("‚û°Ô∏è Abra a aba Editor na UI.");
        else if (where.includes("dash")) out.lines.push("‚û°Ô∏è Abra a aba Dashboard na UI.");
        else out.lines.push("Use: open editor | open dashboard");
        return out;
      }

      // ----- set file -----
      if (cmd === "set") {
        // expects: set file NAME
        const a = norm(args);
        const m = a.match(/^file\s+(.+)$/i);
        if (!m) throw new Error("Use: set file NOMEARQ  (ex: set file app.js)");
        const file = norm(m[1]);
        if (!file) throw new Error("Arquivo inv√°lido.");
        const slug = needActiveApp();
        const app = resolveApp(slug);
        app.files = app.files || {};
        if (!(file in app.files)) {
          // create empty if missing
          app.files[file] = "";
          app.updatedAt = nowISO();
          apps[slug] = app;
          setApps(apps);
        }
        setActiveFile(file);
        pushLog("info", "Active file set", { slug, file });
        setStatus("SET FILE OK");
        out.lines.push("‚úÖ Arquivo ativo: " + file);
        return out;
      }

      // ----- show -----
      if (cmd === "show") {
        const slug = needActiveApp();
        const app = resolveApp(slug);
        const file = getActiveFile();
        const content = (app.files && app.files[file]) ?? "";
        setStatus("SHOW " + file);
        out.lines.push(content || "(vazio)");
        return out;
      }

      // ----- write -----
      if (cmd === "write") {
        const slug = needActiveApp();
        const app = resolveApp(slug);
        const file = getActiveFile();

        // inline write <<< >>>
        const inline = parseWriteInline(raw);
        if (inline !== null) {
          const patch = makePatch("FILE_WRITE", {
            slug,
            file,
            content: inline,
            note: "WRITE inline <<< >>>"
          });

          if (modes.auto && !modes.safe) {
            applyPatch(patch);
            setPending(null);
            setStatus("WRITE ‚Äî aplicado");
            out.lines.push("‚úÖ Aplicado direto em: " + file);
          } else {
            setPending(patch);
            setStatus("WRITE ‚Äî patch pendente");
            out.lines.push("üìå Patch pendente criado (FILE_WRITE).");
            out.lines.push("Use: apply  (ou bot√£o Aprovar sugest√£o)");
          }
          return out;
        }

        // enter write mode
        enterWriteMode(slug, file);
        setStatus("WRITE MODE ON");
        out.lines.push("üü¢ WRITE MODE ativado.");
        out.lines.push("Cole seu texto/c√≥digo em mensagens grandes (200+ linhas ok).");
        out.lines.push("Quando terminar, envie: /end");
        return out;
      }

      // ----- apply / discard / rollback -----
      if (cmd === "apply") {
        const p = getPending();
        if (!p) {
          setStatus("APPLY");
          out.lines.push("Nada pendente.");
          return out;
        }
        const res = applyPatch(p);
        setPending(null);
        setStatus("APPLY OK");
        out.lines.push("‚úÖ Patch aplicado: " + p.type + " (" + p.file + ")");
        return out;
      }

      if (cmd === "discard") {
        const p = getPending();
        setPending(null);
        setStatus("DISCARD");
        out.lines.push(p ? "üóëÔ∏è Patch pendente descartado." : "Nada pendente.");
        return out;
      }

      if (cmd === "rollback") {
        const p = getPending();
        if (!p || !("prevContent" in p)) {
          setStatus("ROLLBACK");
          out.lines.push("Nada para rollback (precisa de patch aplicado com prevContent).");
          return out;
        }
        const r = rollbackPatch(p);
        setStatus("ROLLBACK");
        out.lines.push(r.ok ? "‚Ü©Ô∏è Rollback feito." : "Falhou: " + r.reason);
        return out;
      }

      // ----- mode -----
      if (cmd === "mode") {
        const a = normLower(args);
        const m = a.match(/^(auto|safe)\s+(on|off)$/);
        if (!m) throw new Error("Use: mode auto on|off  ou  mode safe on|off");
        const which = m[1];
        const on = m[2] === "on";
        const next = {};
        next[which] = on;
        const updated = setModes(next);
        setStatus("MODE");
        out.lines.push(`‚úÖ ${which} = ${updated[which] ? "ON" : "OFF"}`);
        out.lines.push(`auto=${updated.auto ? "ON" : "OFF"} | safe=${updated.safe ? "ON" : "OFF"}`);
        return out;
      }

      // ----- unknown -----
      throw new Error("Comando n√£o reconhecido. Use: help");

    } catch (e) {
      out.ok = false;
      out.title = "ERRO";
      out.lines.push(String(e?.message || e));
      pushLog("error", "Command error", { input: raw, error: String(e?.message || e) });
      return out;
    }
  }

  // Expose public API for app.js / UI
  window.RCF = window.RCF || {};
  window.RCF.core = {
    run,
    getApps,
    getActiveSlug,
    getActiveFile,
    getPending,
    getModes,
    getLogs: () => loadJSON(KEY.LOGS, []),
    clearLogs: () => saveJSON(KEY.LOGS, []),
    setActiveSlug,
    setActiveFile,
    setPending
  };

  pushLog("info", "core/commands.js loaded", { version: "v1-single" });
})();
